%!TeX root = ../../Tesi.tex
Un'implementazione del metodo di Jacobi, che beneficia delle funzionalit\`a del linguaggio MATLAB per il
calcolo parallelo presentate nel corso del capitolo \ref{cap:unLinguaggioPerIlCalcoloParalleloMATLAB}, \`e riportata in appendice \ref{app:codiceSorgenteJacobi}.

\subsection{Prototipo e semantica dei parametri}
L'interfaccia della funzione, cos\`i come il codice vero e proprio, sono ispirati dalla funzione MATLAB
\lstinline{pcg} per la risoluzione di sistemi di equazioni lineari mediante il metodo del gradiente coniugato precondizionato\,\cite{TheMathWorksincPcgSolveSystem},
un metodo iterativo spesso visto come una valida alternativa al metodo di Jacobi per via delle sue propriet\`a di convergenza.

Nello specifico, il prototipo della funzione MATLAB \`e
\lstset{
    style              = MATLAB-editor,
    basicstyle         = \mlttfamily,
    morestring=[d]",
    mlshowsectionrules = true,
    alsoletter={-},
    breakatwhitespace=true
}
\begin{matlabcode}
    [x,flag,relres,iter,resvec]=jacobi(A,b,tol,maxit,x0)
\end{matlabcode}
La funzione \lstinline{jacobi} si aspetta di ricevere come parametri la matrice dei coefficienti $A$ del sistema \eqref{eq:formaMatricialeSistemiLineari} e il corrispondente vettore dei termini noti $\mathbf{b}$.\newline
In aggiunta, l'utente pu\`o specificare i seguenti parametri opzionali:
\begin{itemize}
    \item \lstinline{tol}, la tolleranza $\varepsilon$ nell'approssimazione della soluzione del sistema;
    \item \lstinline{maxit}, il numero massimo di iterazioni consentite;
    \item \lstinline{x0}, il vettore iniziale della successione $\mathbf{\{x^{(k)}\}}$ costruita dal metodo iterativo.
\end{itemize}

Gli argomenti restituiti in output da \lstinline{jacobi} sono:
\begin{itemize}
    \item \lstinline{x}, la soluzione del sistema fornito in input;
    \item \lstinline{flag}, un valore numerico indicante lo stato di uscita dall'esecuzione dell'algoritmo. La tabella \ref{tab:flagJacobi} riassume i possibili valori che \lstinline{flag} pu\`o assumere e il loro significato;
    \item \lstinline{relres}, il residuo normalizzato al termine dell'esecuzione del metodo;
    \item \lstinline{iter}, l'iterazione in cui la soluzione del sistema \lstinline{x} \`e stata calcolata;
    \item \lstinline{resvec}, un \textit{array} in cui ciascun elemento rappresenta il residuo del sistema a ogni passo della risoluzione.
\end{itemize}
\begin{table}[htbp]
    \renewcommand{\arraystretch}{1.2}
    \centering
    \begin{tabularx}{\textwidth}{@{} >{\centering\arraybackslash}m{1.5cm} X @{}}
        \toprule
        Flag & Risultato di convergenza                                                                                                                                                            \\
        \midrule
        0    & \lstinline{jacobi} è riuscito a convergere alla soluzione \lstinline{x}, secondo la tolleranza desiderata \lstinline{tol}, entro il numero massimo di iterazioni \lstinline{maxit}. \\
        \addlinespace
        1    & \lstinline{jacobi} ha raggiunto il numero massimo di iterazioni \lstinline{maxit} senza raggiungere la tolleranza richiesta.                                                        \\
        \addlinespace
        2    & L'algoritmo si è interrotto poiché una delle quantità scalari calcolate è diventata troppo piccola o troppo grande per continuare l'esecuzione.                                     \\
        \bottomrule
    \end{tabularx}
    \caption{Valori assunti dal parametro di output \lstinline{flag} della funzione \lstinline{jacobi} e relativi risultati di convergenza.}
    \label{tab:flagJacobi}
\end{table}
\subsection{Scelte progettuali}
La funzione \lstinline{jacobi} costituisce un'implementazione del metodo di Jacobi presentato nel paragrafo \ref{par:metodoJacobi} con la sola differenza che l'algoritmo non agisce sui
singoli elementi delle matrici, ma esegue le medesime operazioni su intere porzioni di dati.\newline
Questo approccio ci consente di trarre vantaggio, prestazionalmente parlando, \\ dall'\textit{overloading} degli operatori e delle \textit{routine} del linguaggio MATLAB, il cui comportamento viene adattato
alla classe di appartenenza degli operandi e degli argomenti rispettivamente.\newline
A questo proposito, \lstinline{jacobi} pu\`o eseguire le operazioni aritmetiche in virgola mobile con una precisione singola oppure una precisione
doppia, stabilendo di conseguenza la tolleranza predefinita.

Il criterio di arresto adottato \`e basato sul controllo del residuo normalizzato con l'introduzione di un'ulteriore condizione sul numero massimo di
iterazioni consentite al fine di arrivare a una soluzione accettabile; mediamente, una tolleranza molto vicina allo 0 richiede
l'esecuzione di un notevole numero di passi prima di raggiungere una situazione di convergenza.

Il comportamento globale della funzione si fonda sull'ipotesi che l'utente fornisca dei parametri in input adeguati, ovvero che specifichi una matrice dei
coefficienti non singolare e priva di elementi diagonali nulli.\newline
Abbiamo deciso di introdurre un limite al numero di iterazioni proprio per terminare l'esecuzione dell'algoritmo nell'eventualit\`a in cui il metodo venga
impiegato come risolutore di sistemi con matrici malcondizionate o che non rispettino le condizioni necessarie per la sua applicazione.

In accordo con i principi di \textit{design} del processo di parallelizzazione di MATLAB, esposti nel paragrafo \ref{par:parallelComputingToolbox}, la funzione \`e
indipendente dall'allocazione delle risorse computazionali: il codice sorgente del file \lstinline{jacobi.m} pu\`o essere eseguito sia su un
sistema monoprocessore che su un sistema multiprocessore senza differenze nella risoluzione del problema dato.

Inoltre, abbiamo sviluppato una versione specifica dello \textit{script} con supporto diretto agli \textit{array} distribuiti.\newline
Tramite un \textit{wrapper} della versione seriale di \lstinline{jacobi}, lo stesso algoritmo viene eseguito in parallelo da un \textit{pool} di \textit{worker}
quando i parametri attuali sono di tipo distribuito.\newline
La scelta dell'\textit{entry point} per l'esecuzione del programma \`e delegata al \textit{dispatcher} del linguaggio,
mentre tutti gli aspetti relativi alla computazione parallela, a partire dalla suddivisione del \textit{job} tra le unit\`a di lavoro, sono
gestiti automaticamente dallo \textit{scheduler} integrato nell'infrastruttura del Parallel Computing Toolbox.

In ogni caso, abbiamo minimizzato il numero di operazioni che necessitano un trasferimento di dati tra pi\`u \textit{worker}; ad esempio,
l'unione degli \textit{array} distribuiti viene forzata solamente durante la fase di presentazione dei risultati.

